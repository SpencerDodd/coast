import os
import bencode
import unittest
import traceback

"""
This class represents a torrent. It holds information (metadata) about the torrent
as parsed from the .torrent file.
"""
class Torrent:

	def __init__(self):
		"""
		Metadata fields
		"""
		# essential content
		self._info = None								# dictionary
		self._announce = None							# string
		# optional content
		self._announce_list = None						# list
		self._creation_date = None						# int
		self._comment = None							# string
		self._created_by = None							# string
		self._encoding = None							# string

		"""
		Client information fields
		"""
		self.peer_id = None								# string
		self.port = None								# int

		"""
		Tracker request fields
		"""
		self.info_hash = None							# string
		self.bytes_downloaded = 0						# int
		self.bytes_uploaded = 0							# int
		self.bytes_left = None							# int
		self.compact = 0								# string
		self.no_peer_id = 0								# int
		self.event = "started"							# string
		self.ip = None									# string
		self.key = None									# (string or int)
		self.trackerid = None							# string

		"""
		Tracker response fields
		"""
		self.failure_reason = None						# string
		self.warning_message = None						# string
		self.interval = None							# int
		self.last_announce = None						# int
		self.min_announce_interval = None				# int
		self.tracker_id = None							# string
		self.seeders = None 							# int
		self.leechers = None							# int
		self.peers = None 								# string or dictionary

		"""
		Status fields for the torrent
		"""
		self.metadata_initialized = False
		self.event_set = False

	"""
	Fills in torrent information by reading from a metadata file (.torrent)
	"""
	def initialize_metadata_from_file(self, metadata_file_path):
		# check if we have a torrent file
		if ".torrent" == metadata_file_path[-8:]:
			try:
				with open(metadata_file_path, "r") as metadata_file:
					metadata = metadata_file.read()
					decoded_data = bencode.bdecode(metadata)

					# fill in our essential fields
					self._announce = decoded_data["announce"]
					self._info = decoded_data["info"]
					# fill in our optional fields if they exist
					meta_keys = decoded_data.keys()
					if "announce-list" in meta_keys:
						self._announce_list = decoded_data["announce-list"]
					if "creation date" in meta_keys:
						self._creation_date = decoded_data["creation date"]
					if "comment" in meta_keys:
						self._comment = decoded_data["comment"]
					if "created by" in meta_keys:
						self._created_by = decoded_data["created by"]
					if "encoding" in meta_keys:
						self._encoding = decoded_data["encoding"]

				self.metadata_initialized = True

			except Exception as e:
				error_message = "File is improperly formatted\n{}".format(traceback.format_exc(e))
				raise ValueError(error_message)


		else:
			raise ValueError("File is not .torrent type")

	"""
	Initializes the torrent for requests to the tracker
	"""
	def intialize_for_tracker_requests(self, peer_id, port):
		if self.metadata_initialized:
			self.peer_id = peer_id
			self.port = port
			self.info_hash = hashlib.sha1(self._info).digest()
			self.bytes_left = self._info["length"]
		else:
			raise AttributeError("Torrent metadata not initialized")

		"""
	Make a request to a tracker about a given torrent

	The tracker is an HTTP/HTTPS service which responds to HTTP GET requests. 
	The requests include metrics from clients that help the tracker keep 
	overall statistics about the torrent. The response includes a peer list 
	that helps the client participate in the torrent. The base URL consists 
	of the "announce URL" as defined in the metainfo (.torrent) file. The 
	parameters are then added to this URL, using standard CGI methods (i.e. 
	a '?' after the announce URL, followed by 'param=value' sequences separated 
	by '&').

	Parameters used in the client->tracker GET are as follows:
	(From the unofficial spec: https://wiki.theory.org/BitTorrentSpecification)

		info_hash: urlencoded 20-byte SHA1 hash of the value of the info key 
			from the Metainfo file. Note that the value will be a bencoded 
			dictionary, given the definition of the info key above.

		peer_id: urlencoded 20-byte string used as a unique ID for the client, 
			generated by the client at startup. This is allowed to be any 
			value, and may be binary data. There are currently no guidelines 
			for generating this peer ID. However, one may rightly presume that 
			it must at least be unique for your local machine, thus should 
			probably incorporate things like process ID and perhaps a 
			timestamp recorded at startup. See peer_id below for common client 
			encodings of this field.

		port: The port number that the client is listening on. Ports reserved 
			for BitTorrent are typically 6881-6889. Clients may choose to give 
			up if it cannot establish a port within this range.

		uploaded: The total amount uploaded (since the client sent the 
			'started' event to the tracker) in base ten ASCII. While not 
			explicitly stated in the official specification, the concensus is 
			that this should be the total number of bytes uploaded.

		downloaded: The total amount downloaded (since the client sent the 
			'started' event to the tracker) in base ten ASCII. While not 
			explicitly stated in the official specification, the consensus is 
			that this should be the total number of bytes downloaded.

		left: The number of bytes this client still has to download in base 
			ten ASCII. Clarification: The number of bytes needed to download to
			be 100% complete and get all the included files in the torrent.

		compact: Setting this to 1 indicates that the client accepts a compact 
			response. The peers list is replaced by a peers string with 6 bytes
			per peer. The first four bytes are the host (in network byte order)
			, the last two bytes are the port (again in network byte order). 
			It should be noted that some trackers only support compact 
			responses (for saving bandwidth) and either refuse requests 
			without "compact=1" or simply send a compact response unless the 
			request contains "compact=0" (in which case they will refuse the 
			request.)

		no_peer_id: Indicates that the tracker can omit peer id field in peers 
			dictionary. This option is ignored if compact is enabled.

		event: If specified, must be one of started, completed, stopped, (or
			empty which is the same as not being specified). If not specified, 
			then this request is one performed at regular intervals.
			`event` flags:
				started: The first request to the tracker must include the 
					event key with this value.
				stopped: Must be sent to the tracker if the client is shutting
					down gracefully.
				completed: Must be sent to the tracker when the download 
					completes. However, must not be sent if the download was 
					already 100% complete when the client started. Presumably,
					this is to allow the tracker to increment the "completed 
					downloads" metric based solely on this event.

		ip: Optional. The true IP address of the client machine, in dotted quad
			format or rfc3513 defined hexed IPv6 address. Notes: In general 
			this parameter is not necessary as the address of the client can 
			be determined from the IP address from which the HTTP request came.
			The parameter is only needed in the case where the IP address that
			the request came in on is not the IP address of the client. This 
			happens if the client is communicating to the tracker through a 
			proxy (or a transparent web proxy/cache.) It also is necessary when
			both the client and the tracker are on the same local side of a NAT
			gateway. The reason for this is that otherwise the tracker would 
			give out the internal (RFC1918) address of the client, which is not
			routable. Therefore the client must explicitly state its (external,
			routable) IP address to be given out to external peers. Various 
			trackers treat this parameter differently. Some only honor it only 
			if the IP address that the request came in on is in RFC1918 space. 
			Others honor it unconditionally, while others ignore it completely.
			In case of IPv6 address (e.g.: 2001:db8:1:2::100) it indicates only
			that client can communicate via IPv6.

		numwant: Optional. Number of peers that the client would like to 
			receive from the tracker. This value is permitted to be zero. If 
			omitted, typically defaults to 50 peers.

		key: Optional. An additional identification that is not shared with 
			any other peers. It is intended to allow a client to prove their 
			identity should their IP address change.

		trackerid: Optional. If a previous announce contained a tracker id, it 
			should be set here.

	"""
	def make_tracker_request(self):
		pass


class TestTorrent(unittest.TestCase):
	
	def test_metadate_from_file(self):
		test_torrent = Torrent()
		root_dir = one_directory_back(os.getcwd())
		test_data_directory = os.path.join(root_dir, "test_data/")
		test_torrent_file = "ubuntu-16.10-desktop-amd64.iso.torrent"
		test_torrent.initialize_metadata_from_file(os.path.join(test_data_directory,test_torrent_file))

		expected_announce = "http://torrent.ubuntu.com:6969/announce"
		expected_announce_list = [
			["http://torrent.ubuntu.com:6969/announce"],
			["http://ipv6.torrent.ubuntu.com:6969/announce"]
		]
		expected_info = {}
		
		expected_info["length"] = 1593835520
		expected_info["name"] = "ubuntu-16.10-desktop-amd64.iso"
		expected_info["piece length"] = 524288
		#expected_info["pieces"] = (Omitted due to size and gibberish)

		self.assertEqual(expected_announce, test_torrent._announce)
		self.assertEqual(expected_announce_list, test_torrent._announce_list)
		self.assertEqual(expected_info["length"], test_torrent._info["length"])
		self.assertEqual(expected_info["name"], test_torrent._info["name"])
		self.assertEqual(expected_info["piece length"], test_torrent._info["piece length"])
		self.assertEqual(60800, len(test_torrent._info["pieces"]))

if __name__ == "__main__":
	unittest.main()























