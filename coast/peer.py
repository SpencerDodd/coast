import time
import unittest
from helpermethods import convert_hex_to_int
from messages import Message, PieceMessage, InterestedMessage, RequestMessage
from bitarray import bitarray
"""
This class represents a peer
"""


class Peer:
	def __init__(self, peer_chunk):
		self.ip = ""
		self.port = None
		self.peer_id = None
		self.byte_string_chunk = self.initialize_with_chunk(peer_chunk)
		self.bitfield = bitarray(endian="big")
		self.received_message_buffer = []
		self.outgoing_message_buffer = []
		self.time_since_last_message = None

		# for interaction with Torrent object
		self.current_piece = None

		# our control
		self.am_choking = True
		self.am_interested = False

		# peer control
		self.peer_choking = True
		self.peer_interested = False

	def initialize_with_chunk(self, byte_string_chunk):
		"""
		Initializes the peer from the given byte-string chunk that is expected to come from the
		`peers` key of the tracker response.

		:param byte_string_chunk: byte-string containing peer info
		:return: byte-string for reference
		"""
		self.byte_string_chunk = byte_string_chunk
		ip_chunk = byte_string_chunk[:4]
		port_chunk = byte_string_chunk[4:]

		for index, char in enumerate(ip_chunk):
			if index != 3:
				self.ip += str(ord(char)) + "."
			else:
				self.ip += str(ord(char))

		self.port = ord(port_chunk[0]) * 256 + ord(port_chunk[1])
		return byte_string_chunk

	def status(self):
		"""
		Returns a string of the status of the peer including debug information such as messages
		received, bitfield, ip, port, id, etc
		:return: string
		"""
		if self.current_piece is None:
			status_string = "Status of peer <<||{}||>>".format(self.peer_id) + \
				"\n\tip: {}".format(self.ip) + \
				"\n\tport: {}".format(self.port) + \
				"\n\tbitfield: {}".format(self.bitfield) + \
				"\n\tmessages: {}".format("".join(a.debug_values() for a in self.received_message_buffer)) + \
				"\n\tpiece: {}".format(self.current_piece)
		else:
			status_string = "Status of peer <<||{}||>>".format(self.peer_id) + \
							"\n\tip: {}".format(self.ip) + \
							"\n\tport: {}".format(self.port) + \
							"\n\tbitfield: {}".format(self.bitfield) + \
							"\n\tmessages: {}".format(
								"".join(a.debug_values() for a in self.received_message_buffer)) + \
							"\n\tpiece: {}".format(self.current_piece.debug_string())

		return status_string

	def get_next_messages(self):
		"""
		Gets the next outgoing messages for the peer protocol based on the newest status of the
		peer. The general flow of messages is:
			- Incoming (remote peer) update peer
			- Torrent updates according to peer changes
			- Peer updates according to torrent changes
			- Protocol sends new messages generated by Peer
		:return: Array of Messages
		"""
		# remove all previous messages
		# TODO: Message buffer is not being deleted

		print ("Removing previous outgoing messages")
		del self.outgoing_message_buffer[:]

		if self.am_interested != 1:
			self.outgoing_message_buffer.append(InterestedMessage())
			self.am_interested = 1
		elif self.current_piece is not None and not self.current_piece.is_complete:
			# class PieceMessage(Message):
			# 	def __init__(self, index=None, begin=None, block=None, data=None):
			next_begin = self.current_piece.get_next_begin()
			# class RequestMessage(Message):
			# 	def __init__(self, index=None, begin=None, data=None):
			next_request = RequestMessage(index=self.current_piece.index, begin=next_begin)
			self.outgoing_message_buffer.append(next_request)

		return self.outgoing_message_buffer

	def received_bitfield(self):
		return len(self.bitfield.tolist()) > 0

	def update_last_contact(self):
		"""
		Updates the time the last message was sent to the remote peer to determine if a keep-alive
		should be sent. Connections are closed remotely after 2 minutes of inactivity, so if we
		reach around 1:45 we should send a keep-alive message to the peer.
		:return: void
		"""
		pass

	def finished_with_piece(self):
		"""
		Returns true if the piece is done downloading
		:return: boolean
		"""
		return self.current_piece.is_complete()

	def get_next_piece(self, next_piece):
		"""
		Sets the current piece to the given next piece and returns the previous current piece
		to be saved to disk by the torrent.

		:param next_piece: Piece to be downloaded
		:return: Finished piece
		"""
		previous_piece = self.current_piece
		self.current_piece = next_piece
		return previous_piece

	def has_piece(self, index):
		if len(self.bitfield.tolist()) == 0:
			return False
		else:
			return self.bitfield[index] == 1

	def set_piece(self, piece):
		self.current_piece = piece

	def process_choke(self, message):
		self.received_message_buffer.append(message)
		print ("Choked by peer <||{}||>".format(self.peer_id))
		self.peer_choking = True

	def process_unchoke(self, message):
		self.received_message_buffer.append(message)
		print ("Unchoked by peer <||{}||>".format(self.peer_id))
		self.peer_choking = False

	def process_interested(self, message):
		self.received_message_buffer.append(message)
		print ("Peer <||{}||> is interested".format(self.peer_id))
		self.peer_interested = True

	def process_not_interested(self, message):
		self.received_message_buffer.append(message)
		print ("Peer <||{}||> is not interested".format(self.peer_id))
		self.peer_interested = False

	def process_have(self, message):
		self.received_message_buffer.append(message)
		piece = message.payload
		print ("Peer <||{}||> has piece {}".format(self.peer_id, piece))
		self.bitfield[convert_hex_to_int(message.payload)] = 1

	def process_bitfield(self, message):
		"""
		The bitfield is a byte representation of pieces. Each bit of each byte in the bitfield
		represents the peer's ability to produce that piece (index 0 based from the first bit).
		Bytes are big endian in the BitTorrent protocol.

		bitfield.get(index) == 0 -> peer does not have piece at index
		bitfield.get(index) == 1 -> peer has piece at index

		:param message: bitfield as byte-string
		"""
		# P.O.C for ubuntu-16.10-desktop-amd64.iso.torrent
		# 60800 piece bytes / (20 bytes / piece) = 3040 pieces
		# 3040 pieces / 8 bits per byte  = 380
		# length of bitfield = 380
		# so each byte of the bitfield represents
		self.received_message_buffer.append(message)
		print ("Processing bitfield from peer <||{}||>".format(self.peer_id))
		self.bitfield.frombytes(message.payload)
		self.bitfield.tolist()

	def process_request(self, message):
		self.received_message_buffer.append(message)
		requested_piece = message.payload
		print ("Peer <||{}||> is requesting {}".format(self.peer_id, requested_piece))

	def process_piece(self, message):
		self.received_message_buffer.append(message)
		new_piece_message = PieceMessage(message.payload)
		print ("Peer <||{}||> sent piece index {} begin {}".format(self.peer_id,
																	new_piece_message.index,
																	new_piece_message.begin))
		self.current_piece.append_data(new_piece_message)

	def process_cancel(self, message):
		self.received_message_buffer.append(message)
		piece = message.payload
		print ("Peer <||{}||> has cancelled request for piece {}".format(self.peer_id, piece))

	def process_port(self, message):
		self.received_message_buffer.append(message)
		port = message.payload
		print ("Peer <||{}||> has sent port {}".format(self.peer_id, port))

	def process_extended_handshake(self, message):
		self.received_message_buffer.append(message)
		extension = message.payload
		print ("Peer <||{}||> has sent extension {}".format(self.peer_id, extension))
